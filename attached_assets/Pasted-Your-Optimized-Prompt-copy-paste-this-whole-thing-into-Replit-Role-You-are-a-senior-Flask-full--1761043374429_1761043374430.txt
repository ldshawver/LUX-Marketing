Your Optimized Prompt (copy–paste this whole thing into Replit):

Role: You are a senior Flask full-stack engineering team (Backend, Frontend, QA, DevOps, AI Integration Lead) tasked with delivering tested, production-ready feature upgrades for the LUX Marketing Platform, currently built with Flask, SQLAlchemy, Jinja2 and deployed at https://lux.lucifercruz.com.

Absolute requirements:
	•	Return a fully working app that runs end-to-end with zero syntax/runtime errors.
	•	Provide automated tests (unit, integration), CI, migrations, docs, and a demo seed.
	•	Integrate cleanly with the existing stack (do NOT change to Node/React).
	•	Where provider keys are missing, gracefully disable features with clear tooltips.

⸻

1) Mission

Expand LUX into a comprehensive AI-powered marketing suite covering Email, SMS, Social, Ads & SEO, Blog/Newsletter, Ecommerce, Reporting, Automations, and Events/Payments—all production-ready, test-backed, and integrated with the current Flask ecosystem.

⸻

2) Current Stack (do not replace)
	•	Backend: Flask (Python 3.11+)
	•	DB: SQLAlchemy (PostgreSQL) + Alembic
	•	Frontend: Jinja2 templates, Bootstrap 5, Vanilla JS/AJAX
	•	Auth: Flask-Login (or Flask-Security)
	•	Background Jobs: Celery + Redis
	•	Email Provider: SMTP and/or Mailgun/SendGrid
	•	Deployment: Gunicorn + Nginx (Ubuntu 22.04)
	•	CI/CD: GitHub Actions → deploy to lux.lucifercruz.com

All new code must be Flask Blueprints, SQLAlchemy models, Jinja templates, and pytest suites that slot into this architecture.

⸻

3) Feature Upgrades (implement fully)

Email Marketing
	•	Drag-and-drop editor (GrapesJS or comparable) embedded in Flask page
	•	BrandKit (logo, colors, fonts), AI copy generator, templates, dynamic content blocks (segment/token aware)
	•	Subject line A/B testing with AI suggestions + personalization tokens
	•	Scheduling (Celery) and resend to non-openers
	•	Reporting: reach/engagement, drilldown, engagement heat map, newsletter archive, inbox preview (local HTML/mobile preview; 3rd-party if key provided)
	•	Providers: Mailgun/SMTP adapters (pluggable strategy)

SMS Marketing
	•	Twilio: campaigns, text-to-join keywords, STOP/HELP compliance, delivery/engagement reporting

Social Marketing
	•	Schedule/post to Facebook Pages, Instagram (Graph API), LinkedIn
	•	Short video posting if API allows
	•	AI captions/hashtags, calendar view, basic social reporting

Automations
	•	Visual builder (trigger → conditions → actions)
	•	Templates: Welcome, Re-engagement, Birthday, Abandoned cart
	•	AI Campaign Builder wizard (brief → subject/body/image prompts → schedule)
	•	Resend to non-openers

Ecommerce + Payments
	•	WooCommerce connector (if keys present): products/customers sync, purchase events, abandoned cart
	•	Stripe Checkout: products/services sales, event tickets
	•	Revenue attribution (first/last/linear), UTM tracking

Reporting & Analytics
	•	Cross-channel dashboards (email, SMS, social, ads, SEO)
	•	Drilldown, CSV/PDF export, marketing calendar, campaign builder
	•	GA4 UTM guidance

SEO & Ads
	•	SEO scan (crawler): meta/titles/H1/links/robots/sitemap → prioritized recommendations + scores + CSV export
	•	Ads: Google Ads basic creation + spend/ROAS (read APIs); Facebook Lookalike audiences

Contacts
	•	CRUD, segments (engagement/ecommerce/tags), web signup forms (reCAPTCHA), import/export CSV
	•	Contact timeline (opens, clicks, SMS, social interactions where available)

Events & Calendar
	•	Event registration forms + Stripe tickets, attendee export
	•	Marketing calendar with color-coded channels

Admin + Brand Tools
	•	BrandKit UI, AI recommendations by brand style
	•	Roles: Admin, Marketer, Viewer

⸻

4) Architecture Requirements
	•	Each feature is its own Flask Blueprint under lux/blueprints/<feature> with routes.py, api.py, services.py, tasks.py as applicable
	•	REST API mounted under /api/v1/*
	•	Shared services in lux/core (OpenAI helpers, email providers, jobs, validators)
	•	Models in lux/models, Base mixins in lux/models/base.py
	•	Templates in lux/templates/<feature>/*.html, static assets in lux/static/<feature>/
	•	Use CSRF protection, rate limiting for public endpoints, input validation, idempotent jobs, retries/backoff, and DLQ for Celery

⸻

5) Testing & Quality
	•	pytest suites for models, routes, services, Celery tasks
	•	Integration tests (email flow, SMS opt-in, social scheduling, automation run)
	•	pytest -q --cov=lux must pass in CI with ≥90% coverage
	•	Seed script populates demo contacts, products, campaigns, posts, automations

⸻

6) Deliverables
	1.	Updated Flask repo per structure below
	2.	requirements.txt, Alembic migrations, .env.example
	3.	README.md (setup, run, feature matrix), DEPLOY.md, LIMITATIONS.md
	4.	GitHub Actions workflow running lint/tests/coverage
	5.	Screenshots embedded in README showing “All tests passed ✅” and dashboard with seeded data

⸻

7) Definition of Done
	•	flask db upgrade succeeds
	•	flask run starts app without errors at http://localhost:5000
	•	All tests pass in CI (verify target)
	•	At least one working automation (e.g., welcome series) demonstrated with a test contact
	•	Disabled states with tooltips where provider keys are missing

⸻

8) Repo Structure Map (use exactly this)

lux-marketing/
├─ README.md
├─ DEPLOY.md
├─ LIMITATIONS.md
├─ .env.example
├─ requirements.txt
├─ pyproject.toml
├─ setup.cfg
├─ .flake8
├─ .gitignore
├─ Makefile
├─ wsgi.py
├─ manage.py
├─ docker-compose.yml
├─ Dockerfile
├─ .github/
│  └─ workflows/
│     └─ ci.yml
├─ alembic.ini
├─ alembic/
│  ├─ env.py
│  ├─ script.py.mako
│  └─ versions/
├─ scripts/
│  ├─ demo_data.py
│  ├─ backfill_metrics.py
│  └─ export_reports.py
├─ lux/
│  ├─ __init__.py
│  ├─ config.py
│  ├─ extensions.py
│  ├─ core/
│  │  ├─ ai.py
│  │  ├─ utils.py
│  │  ├─ security.py
│  │  ├─ jobs.py
│  │  └─ emails.py
│  ├─ models/
│  │  ├─ base.py
│  │  ├─ user.py
│  │  ├─ brand.py
│  │  ├─ contact.py
│  │  ├─ campaign.py
│  │  ├─ automation.py
│  │  ├─ sms.py
│  │  ├─ social.py
│  │  ├─ ecommerce.py
│  │  ├─ events.py
│  │  ├─ seo.py
│  │  └─ reporting.py
│  ├─ blueprints/
│  │  ├─ auth/
│  │  ├─ email/
│  │  ├─ sms/
│  │  ├─ social/
│  │  ├─ automation/
│  │  ├─ contacts/
│  │  ├─ ecommerce/
│  │  ├─ seo/
│  │  ├─ reports/
│  │  ├─ ads/
│  │  ├─ events/
│  │  └─ admin/
│  ├─ templates/
│  │  ├─ layouts/
│  │  ├─ partials/
│  │  ├─ email/
│  │  ├─ sms/
│  │  ├─ social/
│  │  ├─ automation/
│  │  ├─ contacts/
│  │  ├─ ecommerce/
│  │  ├─ seo/
│  │  ├─ reports/
│  │  ├─ ads/
│  │  └─ events/
│  ├─ static/
│  │  ├─ css/
│  │  ├─ js/
│  │  └─ img/
│  └─ api/
│     ├─ __init__.py
│     └─ v1.py
└─ tests/
   ├─ conftest.py
   ├─ factories.py
   ├─ unit/
   ├─ integration/
   └─ e2e/



⸻

9) Key Implementation Snippets (must include)

9.1 App Factory & Blueprint Registration

# lux/__init__.py
from flask import Flask
from .extensions import db, migrate, login_manager, limiter
from .api.v1 import api_bp
from .blueprints.email import bp as email_bp
from .blueprints.sms import bp as sms_bp
from .blueprints.social import bp as social_bp
from .blueprints.contacts import bp as contacts_bp
# ... import other blueprints similarly

def create_app(config_object="lux.config.ProdConfig"):
    app = Flask(__name__)
    app.config.from_object(config_object)

    db.init_app(app)
    migrate.init_app(app, db)
    login_manager.init_app(app)
    limiter.init_app(app)

    app.register_blueprint(api_bp, url_prefix="/api/v1")
    app.register_blueprint(email_bp, url_prefix="/email")
    app.register_blueprint(sms_bp, url_prefix="/sms")
    app.register_blueprint(social_bp, url_prefix="/social")
    app.register_blueprint(contacts_bp, url_prefix="/contacts")
    # ...

    @app.get("/healthz")
    def healthz(): return {"ok": True}, 200

    return app

9.2 Extensions

# lux/extensions.py
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

db = SQLAlchemy()
migrate = Migrate()
login_manager = LoginManager()
limiter = Limiter(key_func=get_remote_address)

9.3 Base Model Mixins

# lux/models/base.py
import uuid, datetime as dt
from sqlalchemy import Column, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import declarative_mixin

@declarative_mixin
class TimestampMixin:
    created_at = Column(DateTime, default=dt.datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=dt.datetime.utcnow,
                        onupdate=dt.datetime.utcnow, nullable=False)

@declarative_mixin
class UUIDMixin:
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

9.4 Versioned API Mount

# lux/api/v1.py
from flask import Blueprint
api_bp = Blueprint("api_v1", __name__)
# Import to register nested blueprints
from lux.blueprints.email.api import bp as email_api_bp  # noqa
from lux.blueprints.sms.api import bp as sms_api_bp      # noqa
# ...
api_bp.register_blueprint(email_api_bp, url_prefix="/email")
api_bp.register_blueprint(sms_api_bp, url_prefix="/sms")

9.5 Provider-Agnostic Email Service

# lux/core/emails.py
import smtplib, ssl, requests
from email.mime.text import MIMEText
from flask import current_app

class EmailProvider:  # interface
    def send(self, to, subject, html, headers=None): raise NotImplementedError

class SMTPProvider(EmailProvider):
    def send(self, to, subject, html, headers=None):
        msg = MIMEText(html, "html")
        msg["Subject"], msg["To"], msg["From"] = subject, to, current_app.config.get("SMTP_FROM")
        ctx = ssl.create_default_context()
        with smtplib.SMTP(current_app.config["SMTP_HOST"], current_app.config.get("SMTP_PORT", 587)) as s:
            s.starttls(context=ctx)
            s.login(current_app.config["SMTP_USER"], current_app.config["SMTP_PASS"])
            s.sendmail(msg["From"], [to], msg.as_string())

class MailgunProvider(EmailProvider):
    def send(self, to, subject, html, headers=None):
        resp = requests.post(
            f"https://api.mailgun.net/v3/{current_app.config['MAILGUN_DOMAIN']}/messages",
            auth=("api", current_app.config["MAILGUN_API_KEY"]),
            data={"from": current_app.config["MAILGUN_FROM"], "to": [to], "subject": subject, "html": html},
            timeout=15,
        )
        resp.raise_for_status()

def get_provider():
    if current_app.config.get("MAILGUN_API_KEY"): return MailgunProvider()
    return SMTPProvider()

9.6 AI Guardrails

# lux/core/ai.py
import re

FORBIDDEN = {"click here", "free $$$", "viagra"}
def validate_text(txt:str):
    issues = []
    if not txt.strip(): issues.append("Empty text")
    if len(txt) > 2000: issues.append("Too long")
    if any(w in txt.lower() for w in FORBIDDEN): issues.append("Spam phrase")
    if re.search(r"\{\{.*\}\}", txt) is None: issues.append("Missing personalization token e.g. {{ contact.first_name }}")
    return (len(issues) == 0, issues)

def suggest_subject(brief:str, brand_style:dict) -> str:
    # Call OpenAI if OPENAI_API_KEY present (pseudo; replace with actual client)
    base = f"{brief[:60]} | {brand_style.get('tone','On-brand')}"
    subj = base[:78]
    ok, issues = validate_text(subj + " {{ contact.first_name }}")
    return subj + " {{ contact.first_name }}"



⸻

10) CI, Makefile, and Env

Makefile

install:
\tpip install -r requirements.txt
db:
\tflask db upgrade
test:
\tpytest -q --cov=lux --cov-report=term-missing
lint:
\tflake8 lux tests
verify: install lint db test

GitHub Actions

# .github/workflows/ci.yml
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - run: pip install -r requirements.txt
      - run: flask db upgrade || true
      - run: pytest -q --cov=lux --cov-report=xml

.env.example

FLASK_ENV=production
SECRET_KEY=
DATABASE_URL=postgresql+psycopg2://user:pass@localhost:5432/lux
REDIS_URL=redis://localhost:6379/0
SMTP_HOST=
SMTP_PORT=587
SMTP_USER=
SMTP_PASS=
SMTP_FROM=
MAILGUN_API_KEY=
MAILGUN_DOMAIN=
MAILGUN_FROM=
TWILIO_ACCOUNT_SID=
TWILIO_AUTH_TOKEN=
OPENAI_API_KEY=
STRIPE_SECRET_KEY=
FB_APP_TOKEN=
GOOGLE_ADS_KEY=
RECAPTCHA_SITE_KEY=
RECAPTCHA_SECRET_KEY=
GA4_MEASUREMENT_ID=



⸻

11) Starter Alembic Migration (initial tables)

Create file alembic/versions/0001_initial.py:

"""initial schema"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers
revision = "0001_initial"
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    op.execute("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";")
    uid = postgresql.UUID(as_uuid=True)

    op.create_table("brand",
        sa.Column("id", uid, primary_key=True, server_default=sa.text("uuid_generate_v4()")),
        sa.Column("name", sa.String(120), nullable=False),
        sa.Column("logo_url", sa.String(512)),
        sa.Column("primary_color", sa.String(16)),
        sa.Column("font_family", sa.String(64)),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("updated_at", sa.DateTime(), nullable=False),
    )

    op.create_table("contact",
        sa.Column("id", uid, primary_key=True, server_default=sa.text("uuid_generate_v4()")),
        sa.Column("email", sa.String(255), nullable=False, unique=True),
        sa.Column("first_name", sa.String(80)),
        sa.Column("last_name", sa.String(80)),
        sa.Column("tags", sa.ARRAY(sa.String(64)), server_default="{}"),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("updated_at", sa.DateTime(), nullable=False),
    )

    op.create_table("campaign",
        sa.Column("id", uid, primary_key=True, server_default=sa.text("uuid_generate_v4()")),
        sa.Column("brand_id", uid, sa.ForeignKey("brand.id", ondelete="CASCADE"), nullable=False),
        sa.Column("name", sa.String(160), nullable=False),
        sa.Column("channel", sa.String(32), nullable=False),  # email/sms/social
        sa.Column("subject", sa.String(200)),
        sa.Column("html", sa.Text()),
        sa.Column("scheduled_at", sa.DateTime()),
        sa.Column("status", sa.String(32), server_default="draft"),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("updated_at", sa.DateTime(), nullable=False),
    )

    op.create_table("message_event",
        sa.Column("id", uid, primary_key=True, server_default=sa.text("uuid_generate_v4()")),
        sa.Column("campaign_id", uid, sa.ForeignKey("campaign.id", ondelete="CASCADE"), nullable=False),
        sa.Column("contact_id", uid, sa.ForeignKey("contact.id", ondelete="CASCADE"), nullable=False),
        sa.Column("type", sa.String(32), nullable=False),  # sent/open/click/bounce
        sa.Column("meta", sa.JSON(), server_default=sa.text("'{}'::jsonb")),
        sa.Column("occurred_at", sa.DateTime(), nullable=False),
    )

def downgrade():
    op.drop_table("message_event")
    op.drop_table("campaign")
    op.drop_table("contact")
    op.drop_table("brand")



⸻

12) Demo Data Seeder (scripts/demo_data.py)

"""
Seed demo data so the dashboard is clickable out of the box.
Run:  python scripts/demo_data.py
"""
import os, random, datetime as dt
from lux import create_app
from lux.extensions import db
from lux.models.brand import Brand  # implement simple Brand model using mixins
from lux.models.contact import Contact
from lux.models.campaign import Campaign, MessageEvent  # simple models aligned with migration

def main():
    app = create_app("lux.config.DevConfig")
    with app.app_context():
        db.create_all()  # or rely on alembic upgrade prior
        if not Brand.query.first():
            brand = Brand(name="LUX Demo", primary_color="#111111", font_family="Inter")
            db.session.add(brand)
            db.session.flush()

            # Contacts
            contacts = []
            for i in range(50):
                c = Contact(email=f"demo{i}@example.com", first_name=f"User{i}", last_name="Demo", tags=["demo","warm"])
                contacts.append(c)
            db.session.add_all(contacts); db.session.flush()

            # Campaign
            camp = Campaign(brand_id=brand.id, name="Welcome Series 1", channel="email",
                            subject="Welcome to LUX {{ contact.first_name }}",
                            html="<h1>Hi {{ contact.first_name }}</h1><p>Thanks for joining.</p>",
                            scheduled_at=dt.datetime.utcnow() + dt.timedelta(hours=1))
            db.session.add(camp); db.session.flush()

            # Events
            now = dt.datetime.utcnow()
            evts = []
            for c in contacts:
                evts.append(MessageEvent(campaign_id=camp.id, contact_id=c.id, type="sent", occurred_at=now))
                if random.random() > 0.3:
                    evts.append(MessageEvent(campaign_id=camp.id, contact_id=c.id, type="open", occurred_at=now+dt.timedelta(minutes=5)))
                if random.random() > 0.7:
                    evts.append(MessageEvent(campaign_id=camp.id, contact_id=c.id, type="click", occurred_at=now+dt.timedelta(minutes=10)))
            db.session.add_all(evts)
            db.session.commit()
            print("✅ Demo data seeded.")
        else:
            print("ℹ️ Demo data already present.")

if __name__ == "__main__":
    main()



⸻

13) README setup (must include)

## Quickstart
```bash
python -m venv .venv && source .venv/bin/activate
pip install -r requirements.txt
cp .env.example .env
flask db upgrade
python scripts/demo_data.py
flask run

	•	To verify: make verify
	•	If provider keys are missing, related UI toggles are disabled with tooltips.

Proof
	•	

	•	

---

# 14) Requirements (minimum)

Flask>=3.0
Flask-SQLAlchemy>=3.1
Flask-Migrate>=4.0
Flask-Login>=0.6
Flask-Limiter>=3.5
psycopg2-binary>=2.9
alembic>=1.13
redis>=5.0
celery>=5.4
python-dotenv>=1.0
requests>=2.32
email-validator>=2.2
factory-boy>=3.3
pytest>=8.0
pytest-cov>=5.0
flake8>=7.0

---

# 15) Final Instructions to Replit (must follow verbatim)

1. **Use the directory map exactly**; create all modules/files/imports to match.  
2. Do **not** change the stack or introduce incompatible frameworks.  
3. Implement all features with graceful degradation when keys are absent (show disabled UI with explanatory tooltips).  
4. Provide **passing tests** and CI workflow.  
5. Ensure the following commands succeed with exit code **0**:
   - `make verify`
   - `flask db upgrade`
   - `flask run`
6. Return repository tree, key files, and embed screenshots (markdown) showing passing tests and a populated dashboard.  
7. Output the final line:  
   **“✅ All tests passing — Ready for Deployment to lux.lucifercruz.com”**.

---

**Key Improvements:** Enforces production standards (tests, CI, migrations), preserves your Flask stack, converts your feature wishlist into concrete modules, adds demo seeds for instant validation, and includes initial schema + service stubs to prevent broken imports.

**Techniques Applied:** Role assignment, constraint-driven spec, acceptance criteria, architectural decomposition, CI-first development, AI guardrails.

**Pro Tip:** If Replit attempts partial delivery, instruct it to iterate until `make verify` passes and the app boots with `flask run` using the seeded demo data.